import psutil
import signal
import subprocess
import shlex
from .utils import *


class John:
    """This class encapsulates all functionality used to run benchmarks with JohnTheRipper."""

    @staticmethod
    def __out(process, exec_time):
        """This function collects the output generated by JohnTheRipper.

                Arguments:
                    process     (process):  the subprocess which is john
                    exec_time   (int):      seconds to run at most

                Returns:
                    cracked     (int):  number of cracked hashes
                    detected    (int):  number of detected hashes
                    speeds      (list): list of recorded speeds
                    times       (list): list of points in time where the speeds were recorded
        """
        # Skipping the first 2 lines as they are not relevant, but contain the number of detected hashes.
        cracked = 0
        speeds = []
        times = []
        process.stdout.readline()
        detected = int(process.stdout.readline().split()[1])
        time_run = 0
        start = time.time()
        # Running while process is still running and maximum execution time has not been reached
        while process.poll() is None and time_run < exec_time:
            # Sending a signal to the process, sending a char via stdin does not work here
            process.send_signal(signal.SIGUSR1)
            list_of_string = process.stdout.readline().split()
            time_of_status = time.time() - start
            # Only considering lines which are long enough
            if len(list_of_string) > 9:
                # Checking the first element as this indicates whether we have a valid line
                first_elem = list_of_string[0][:-1]
                if is_float(first_elem):
                    # Setting first list element to the number of cracked hashes
                    cracked = int(first_elem)
                    # Appending current speed to list
                    speed = next((s for s in list_of_string if "p/s" in s), None)[:-3]
                    speed = unit_converter(speed)
                    speeds.append(float(speed))
                    times.append(time_of_status)
            time_run = time.time() - start
            time.sleep(0.1)
        # Terminating process (for when we reached max_exec_time)
        process.send_signal(signal.SIGTERM)

        return cracked, detected, speeds, times

    @staticmethod
    def __multi_out(process, devices, exec_time):
        """This function collects the output generated by JohnTheRipper when running with multiple GPUs.

                Arguments:
                    process     (process):  the subprocess which is john
                    devices     (int):      number of devices used
                    exec_time   (int):      seconds to run at most

                Returns:
                    cracked     (int):  number of cracked hashes
                    detected    (int):  number of detected hashes
                    speeds      (list): list of recorded speeds
                    times       (list): list of points in time where the speeds were recorded
        """
        # Initialising lists for each device which will be joined before returning
        devices_speeds = []
        devices_cracked = []
        devices_times = []
        for i in range(devices):
            devices_speeds.append([])
            devices_times.append([])
            devices_cracked.append(0)
        # Skipping the first 2 lines as they are not relevant, but contain the number of detected hashes.
        process.stdout.readline()
        detected = int(process.stdout.readline().split()[1])
        parent = psutil.Process(process.pid)
        children = parent.children()
        # Waiting for children/forks to start
        while not children:
            time.sleep(0.1)
            children = parent.children()
        processes = [parent]
        [processes.append(child) for child in children]
        time_run = 0
        start = time.time()
        while process.poll() is None and time_run < exec_time:
            # Sending signals and receiving from each (forked) process
            for sub_process in processes:
                try:
                    sub_process.send_signal(signal.SIGUSR1)
                except psutil.NoSuchProcess as exception:
                    if "process no longer exists" in exception.msg:
                        pass
                    else:
                        raise exception
                list_of_string = process.stdout.readline().split()
                time_of_status = time.time() - start
                if len(list_of_string) > 9 and is_float(list_of_string[0]):
                    device = list_of_string[0]
                    device = int(device) - 1
                    devices_cracked[device] = int(list_of_string[1][:-1])
                    speed = next((s for s in list_of_string if "p/s" in s), None)[:-3]
                    speed = unit_converter(speed)
                    devices_speeds[device].append(float(speed))
                    devices_times[device].append(time_of_status)

            time_run = time.time() - start
        # Terminating process (for when we reached max_exec_time)
        process.send_signal(signal.SIGTERM)
        # Joining lists
        cracked = sum(devices_cracked)
        speeds = []
        times = []
        # Needed to avoid IndexError in following loop (might have missed status from a device)
        min_length = min(min((map(len, devices_speeds))), min(map(len, devices_times)))
        for i in range(min_length):
            speed = 0
            timepoint = 0
            for j in range(devices):
                speed += devices_speeds[j][i]
                timepoint += devices_times[j][i]
            timepoint /= devices
            speeds.append(speed)
            times.append(timepoint)

        return cracked, detected, speeds, times

    # This function checks how many GPU devices John has detected
    # Enables us to use multiple GPUs as well
    @staticmethod
    def __get_devices(location):
        """Function to get the number of GPUs that can be used.

            Arguments:
                location    (string):   path to john's executable

            Returns:
                nr_gpus     (int):      number of GPUs detected

        """
        process_args = [location, "--list=opencl-devices"]
        process = subprocess.Popen(process_args, universal_newlines=True, stdout=subprocess.PIPE, encoding='utf-8',
                                   errors='ignore')
        out = process.communicate()
        lines = out[0].split("\n")
        nr_gpus = 0
        for line in lines:
            if "Device type" in line:
                if line.split()[2] == "GPU":
                    nr_gpus += 1

        return nr_gpus

    def execute(self, location, mode, hash_type, hash_file, max_exec_time, wordlist, rules,
                min_len, max_len):
        """This function runs the benchmark with hashcat.
                    It constructs the commandline with the correct arguments as they are specified.

            Arguments:
                location        (string):   location of john binary
                mode            (int):      mode flag
                hash_type       (int):      hash type flag
                hash_file       (string):   path to hash file
                max_exec_time   (int):      seconds to run at most
                wordlist        (string):   path to wordlist
                rules           (string):   name of rules (has to be specified in john.conf)
                min_len         (int):      minimum candidate length
                max_len         (int):      maximum candidate length


            Returns:
                The values received from the output reader which are:
                Number of cracked hashes
                Number of detected hashes
                List of recorded speeds
                List of points in time where the speeds were recorded
        """

        # Default maximum runtime is 10h
        if not max_exec_time:
            max_exec_time = 36000

        process_args = location

        # Mode 1 = Brute Force, Mode 0 = Wordlist
        if mode:
            process_args += " --mask=?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a -min-len={} -max-len={} {} --format={}" \
                            " --verbosity=1".format(min_len, max_len, hash_file, hash_type)
        else:
            process_args += " --wordlist={} {} --format={} --verbosity=1".format(wordlist, hash_file, hash_type)
            if rules:
                process_args += " --rules:{}".format(rules)

        # Getting number of available GPUs and setting commandline option accordingly
        multi_gpu = False
        nr_gpus = self.__get_devices(location)
        if nr_gpus == 0:
            raise ValueError("Detected 0 GPUs with John, aborting")
        if nr_gpus > 1:
            multi_gpu = True
            process_args += " -fork={} -dev=gpu".format(nr_gpus)

        # Spawning the subprocess running an instance of john
        process = subprocess.Popen(shlex.split(process_args), universal_newlines=True, stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT, encoding='utf-8', errors='ignore')

        # Calling the output collector
        if multi_gpu:
            cracked, detected, speeds, times = self.__multi_out(process, nr_gpus, max_exec_time)
        else:
            cracked, detected, speeds, times = self.__out(process, max_exec_time)

        return cracked, detected, speeds, times
